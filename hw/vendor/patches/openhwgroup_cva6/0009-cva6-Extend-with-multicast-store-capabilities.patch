From 64d8f0427d58866a8464ae2cf80e4d76c28c01a8 Mon Sep 17 00:00:00 2001
From: Luca Colagrande <luca.colagrande3@gmail.com>
Date: Mon, 4 Sep 2023 18:55:11 +0200
Subject: [PATCH] cva6: Extend with multicast store capabilities

---
 hw/vendor/openhwgroup_cva6/Bender.yml         |   1 +
 .../core/cache_subsystem/cache_ctrl.sv        |   3 +
 .../core/cache_subsystem/miss_handler.sv      |  10 +-
 .../openhwgroup_cva6/core/csr_regfile.sv      |   9 +
 hw/vendor/openhwgroup_cva6/core/cva6.sv       |   3 +
 hw/vendor/openhwgroup_cva6/core/ex_stage.sv   |   2 +
 .../core/include/ariane_pkg.sv                |   1 +
 .../core/include/riscv_pkg.sv                 |   2 +
 .../core/include/std_cache_pkg.sv             |   2 +
 .../openhwgroup_cva6/core/load_store_unit.sv  |   2 +
 hw/vendor/openhwgroup_cva6/core/load_unit.sv  |   1 +
 .../core/mmu_sv32/cva6_ptw_sv32.sv            |   1 +
 .../openhwgroup_cva6/core/mmu_sv39/ptw.sv     |   1 +
 .../openhwgroup_cva6/core/store_buffer.sv     |  20 +-
 hw/vendor/openhwgroup_cva6/core/store_unit.sv |   2 +
 .../corev_apu/tb/axi_mcast_adapter.sv         | 461 ++++++++++++++++++
 16 files changed, 517 insertions(+), 4 deletions(-)
 create mode 100644 hw/vendor/openhwgroup_cva6/corev_apu/tb/axi_mcast_adapter.sv

diff --git a/hw/vendor/openhwgroup_cva6/Bender.yml b/hw/vendor/openhwgroup_cva6/Bender.yml
index 54e2f55a..1b899ccc 100644
--- a/hw/vendor/openhwgroup_cva6/Bender.yml
+++ b/hw/vendor/openhwgroup_cva6/Bender.yml
@@ -178,6 +178,7 @@ sources:
       - core/cache_subsystem/amo_alu.sv
       - core/cache_subsystem/wt_l15_adapter.sv
       - corev_apu/tb/axi_adapter.sv
+      - corev_apu/tb/axi_mcast_adapter.sv
       - core/cache_subsystem/miss_handler.sv
       - core/cache_subsystem/std_nbdcache.sv
       - core/cache_subsystem/cva6_icache_axi_wrapper.sv
diff --git a/hw/vendor/openhwgroup_cva6/core/cache_subsystem/cache_ctrl.sv b/hw/vendor/openhwgroup_cva6/core/cache_subsystem/cache_ctrl.sv
index 1789d7e5..f4209f90 100644
--- a/hw/vendor/openhwgroup_cva6/core/cache_subsystem/cache_ctrl.sv
+++ b/hw/vendor/openhwgroup_cva6/core/cache_subsystem/cache_ctrl.sv
@@ -79,6 +79,7 @@ module cache_ctrl import ariane_pkg::*; import std_cache_pkg::*; #(
         logic [63:0]            wdata;
         logic                   bypass;
         logic                   killed;
+        logic [riscv::PLEN-1:0] mcast_mask;
     } mem_req_t;
 
     logic [DCACHE_SET_ASSOC-1:0] hit_way_d, hit_way_q;
@@ -142,6 +143,7 @@ module cache_ctrl import ariane_pkg::*; import std_cache_pkg::*; #(
                     mem_req_d.we    = req_port_i.data_we;
                     mem_req_d.wdata = req_port_i.data_wdata;
                     mem_req_d.killed = req_port_i.kill_req;
+                    mem_req_d.mcast_mask = req_port_i.mcast_mask;
 
                     // Bypass mode, check for uncacheable address here as well
                     if (bypass_i) begin
@@ -350,6 +352,7 @@ module cache_ctrl import ariane_pkg::*; import std_cache_pkg::*; #(
                 miss_req_o.size = mem_req_q.size;
                 miss_req_o.we = mem_req_q.we;
                 miss_req_o.wdata = mem_req_q.wdata;
+                miss_req_o.mcast_mask = mem_req_q.mcast_mask;
 
                 // got a grant so go to valid
                 if (bypass_gnt_i) begin
diff --git a/hw/vendor/openhwgroup_cva6/core/cache_subsystem/miss_handler.sv b/hw/vendor/openhwgroup_cva6/core/cache_subsystem/miss_handler.sv
index 540e8875..5cc7b7fc 100644
--- a/hw/vendor/openhwgroup_cva6/core/cache_subsystem/miss_handler.sv
+++ b/hw/vendor/openhwgroup_cva6/core/cache_subsystem/miss_handler.sv
@@ -106,6 +106,7 @@ module miss_handler import ariane_pkg::*; import std_cache_pkg::*; #(
     logic [NR_PORTS-1:0]                    miss_req_we;
     logic [NR_PORTS-1:0][7:0]               miss_req_be;
     logic [NR_PORTS-1:0][1:0]               miss_req_size;
+    logic [NR_PORTS-1:0][riscv::PLEN-1:0]   miss_req_mcast_mask;
 
     // Bypass AMO port
     bypass_req_t amo_bypass_req;
@@ -191,6 +192,7 @@ module miss_handler import ariane_pkg::*; import std_cache_pkg::*; #(
         amo_bypass_req.be      = '0;
         amo_bypass_req.size    = 2'b11;
         amo_bypass_req.id      = 4'b1011;
+        amo_bypass_req.mcast_mask = '0;
         // core
         flush_ack_o         = 1'b0;
         miss_o              = 1'b0; // to performance counter
@@ -545,6 +547,7 @@ module miss_handler import ariane_pkg::*; import std_cache_pkg::*; #(
             bypass_ports_req[id].we      = miss_req_we[id];
             bypass_ports_req[id].be      = miss_req_be[id];
             bypass_ports_req[id].size    = miss_req_size[id];
+            bypass_ports_req[id].mcast_mask = miss_req_mcast_mask[id];
 
             bypass_gnt_o[id]   = bypass_ports_rsp[id].gnt;
             bypass_valid_o[id] = bypass_ports_rsp[id].valid;
@@ -553,6 +556,7 @@ module miss_handler import ariane_pkg::*; import std_cache_pkg::*; #(
 
         // AMO port has lowest priority
         bypass_ports_req[id] = amo_bypass_req;
+
         amo_bypass_rsp       = bypass_ports_rsp[id];
     end
 
@@ -579,9 +583,11 @@ module miss_handler import ariane_pkg::*; import std_cache_pkg::*; #(
     // ----------------------
     // Cast bypass_adapter_req.addr to axi_adapter port size
     logic [riscv::XLEN-1:0] bypass_addr;
+    logic [riscv::XLEN-1:0] bypass_mcast_mask;
     assign bypass_addr = bypass_adapter_req.addr;
+    assign bypass_mcast_mask = bypass_adapter_req.mcast_mask;
 
-    axi_adapter #(
+    axi_mcast_adapter #(
         .DATA_WIDTH            ( 64                 ),
         .CACHELINE_BYTE_OFFSET ( DCACHE_BYTE_OFFSET ),
         .AXI_ADDR_WIDTH        ( AXI_ADDR_WIDTH     ),
@@ -600,6 +606,7 @@ module miss_handler import ariane_pkg::*; import std_cache_pkg::*; #(
         .id_i                 (({{AXI_ID_WIDTH-4{1'b0}}, bypass_adapter_req.id})),
         .user_i               (hart_id_i[AXI_USER_WIDTH-1:0] + 1'b1),
         .addr_i               (bypass_addr),
+        .mcast_mask_i         (bypass_mcast_mask),
         .wdata_i              (bypass_adapter_req.wdata),
         .we_i                 (bypass_adapter_req.we),
         .be_i                 (bypass_adapter_req.be),
@@ -680,6 +687,7 @@ module miss_handler import ariane_pkg::*; import std_cache_pkg::*; #(
             miss_req_we     [i]  = miss_req.we;
             miss_req_be     [i]  = miss_req.be;
             miss_req_size   [i]  = miss_req.size;
+            miss_req_mcast_mask[i] = miss_req.mcast_mask;
         end
     end
 endmodule
diff --git a/hw/vendor/openhwgroup_cva6/core/csr_regfile.sv b/hw/vendor/openhwgroup_cva6/core/csr_regfile.sv
index 5ebb5379..de3de5e3 100644
--- a/hw/vendor/openhwgroup_cva6/core/csr_regfile.sv
+++ b/hw/vendor/openhwgroup_cva6/core/csr_regfile.sv
@@ -82,6 +82,8 @@ module csr_regfile import ariane_pkg::*; #(
     output logic [31:0]           fence_t_pad_o,              // Padding time of fence.t relative to time interrupt
     output logic                  fence_t_src_sel_o,          // Pad relative to selected source
     input  logic [31:0]           fence_t_ceil_i,
+    // Multicast
+    output logic[riscv::XLEN-1:0] mcast_mask_o,               // Multicast store mask
     // Performance Counter
     output logic  [4:0]           perf_addr_o,                // read/write address to performance counter module (up to 29 aux counters possible in riscv encoding.h)
     output logic[riscv::XLEN-1:0] perf_data_o,                // write data to performance counter module
@@ -142,6 +144,7 @@ module csr_regfile import ariane_pkg::*; #(
     riscv::xlen_t icache_q,    icache_d;
     riscv::xlen_t fence_t_pad_q, fence_t_pad_d;
     riscv::xlen_t fence_t_ceil_q, fence_t_ceil_d;
+    riscv::xlen_t mcast_mask_q, mcast_mask_d;
 
     logic        wfi_d,       wfi_q;
 
@@ -295,6 +298,7 @@ module csr_regfile import ariane_pkg::*; #(
                 riscv::CSR_ICACHE:           csr_rdata = icache_q;
                 riscv::CSR_FENCE_T_PAD:      csr_rdata = fence_t_pad_q;
                 riscv::CSR_FENCE_T_CEIL:     csr_rdata = fence_t_ceil_q;
+                riscv::CSR_MCAST_MASK:       csr_rdata = mcast_mask_q;
                 // PMPs
                 riscv::CSR_PMPCFG0:          csr_rdata = pmpcfg_q[riscv::XLEN/8-1:0];
                 riscv::CSR_PMPCFG1:          if (riscv::XLEN == 32) csr_rdata = pmpcfg_q[7:4]; else read_access_exception = 1'b1;
@@ -404,6 +408,7 @@ module csr_regfile import ariane_pkg::*; #(
         icache_d                = icache_q;
         fence_t_pad_d           = fence_t_pad_q;
         fence_t_ceil_d          = {fence_t_ceil_q[63:32], (fence_t_ceil_i > fence_t_ceil_q[31:0]) ? fence_t_ceil_i : fence_t_ceil_q[31:0]};
+        mcast_mask_d            = mcast_mask_q;
 
         sepc_d                  = sepc_q;
         scause_d                = scause_q;
@@ -623,6 +628,7 @@ module csr_regfile import ariane_pkg::*; #(
                 riscv::CSR_ICACHE:             icache_d    = {{riscv::XLEN-1{1'b0}}, csr_wdata[0]}; // enable bit
                 riscv::CSR_FENCE_T_PAD:        fence_t_pad_d = {{riscv::XLEN-32{1'b0}}, csr_wdata[31:0]};
                 riscv::CSR_FENCE_T_CEIL:       fence_t_ceil_d = {{riscv::XLEN-31{1'b0}}, csr_wdata[32:0]};
+                riscv::CSR_MCAST_MASK:         mcast_mask_d = csr_wdata;
                 // PMP locked logic
                 // 1. refuse to update any locked entry
                 // 2. also refuse to update the entry below a locked TOR entry
@@ -1100,6 +1106,7 @@ module csr_regfile import ariane_pkg::*; #(
     assign dcache_en_o      = dcache_q[0];
     assign fence_t_pad_o    = fence_t_pad_q;
     assign fence_t_src_sel_o= fence_t_ceil_q[32];
+    assign mcast_mask_o     = mcast_mask_q;
 
     // determine if mprv needs to be considered if in debug mode
     assign mprv             = (debug_mode_q && !dcsr_q.mprven) ? 1'b0 : mstatus_q.mprv;
@@ -1142,6 +1149,7 @@ module csr_regfile import ariane_pkg::*; #(
             icache_q               <= {{riscv::XLEN-1{1'b0}}, 1'b1};
             fence_t_pad_q          <= {riscv::XLEN{1'b0}};
             fence_t_ceil_q         <= {riscv::XLEN{1'b0}};
+            mcast_mask_q           <= {riscv::XLEN{1'b0}};
             // supervisor mode registers
             sepc_q                 <= {riscv::XLEN{1'b0}};
             scause_q               <= {riscv::XLEN{1'b0}};
@@ -1187,6 +1195,7 @@ module csr_regfile import ariane_pkg::*; #(
             icache_q               <= icache_d;
             fence_t_pad_q          <= fence_t_pad_d;
             fence_t_ceil_q         <= fence_t_ceil_d;
+            mcast_mask_q           <= mcast_mask_d;
             // supervisor mode registers
             sepc_q                 <= sepc_d;
             scause_q               <= scause_d;
diff --git a/hw/vendor/openhwgroup_cva6/core/cva6.sv b/hw/vendor/openhwgroup_cva6/core/cva6.sv
index 50f5589a..ce470bec 100644
--- a/hw/vendor/openhwgroup_cva6/core/cva6.sv
+++ b/hw/vendor/openhwgroup_cva6/core/cva6.sv
@@ -217,6 +217,7 @@ module cva6 import ariane_pkg::*; #(
   logic [31:0]              fence_t_pad_csr_ctrl;
   logic                     fence_t_src_sel_csr_ctrl;
   logic [31:0]              fence_t_ceil_csr_ctrl;
+  riscv::xlen_t             mcast_mask;
   logic                     debug_mode;
   logic                     single_step_csr_commit;
   riscv::pmpcfg_t [15:0]    pmpcfg;
@@ -470,6 +471,7 @@ module cva6 import ariane_pkg::*; #(
     // MULT
     .mult_valid_i           ( mult_valid_id_ex            ),
     // LSU
+    .mcast_mask_i           ( mcast_mask                  ),
     .lsu_ready_o            ( lsu_ready_ex_id             ),
     .lsu_valid_i            ( lsu_valid_id_ex             ),
 
@@ -639,6 +641,7 @@ module cva6 import ariane_pkg::*; #(
     .fence_t_pad_o          ( fence_t_pad_csr_ctrl          ),
     .fence_t_src_sel_o      ( fence_t_src_sel_csr_ctrl      ),
     .fence_t_ceil_i         ( fence_t_ceil_csr_ctrl         ),
+    .mcast_mask_o           ( mcast_mask                    ),
     .perf_addr_o            ( addr_csr_perf                 ),
     .perf_data_o            ( data_csr_perf                 ),
     .perf_data_i            ( data_perf_csr                 ),
diff --git a/hw/vendor/openhwgroup_cva6/core/ex_stage.sv b/hw/vendor/openhwgroup_cva6/core/ex_stage.sv
index 20204717..473085dd 100644
--- a/hw/vendor/openhwgroup_cva6/core/ex_stage.sv
+++ b/hw/vendor/openhwgroup_cva6/core/ex_stage.sv
@@ -50,6 +50,7 @@ module ex_stage import ariane_pkg::*; #(
     // MULT
     input  logic                                   mult_valid_i,      // Output is valid
     // LSU
+    input  riscv::xlen_t                           mcast_mask_i,
     output logic                                   lsu_ready_o,        // FU is ready
     input  logic                                   lsu_valid_i,        // Input is valid
 
@@ -298,6 +299,7 @@ module ex_stage import ariane_pkg::*; #(
         .flush_i,
         .no_st_pending_o,
         .fu_data_i             ( lsu_data ),
+        .mcast_mask_i,
         .lsu_ready_o,
         .lsu_valid_i,
         .load_trans_id_o,
diff --git a/hw/vendor/openhwgroup_cva6/core/include/ariane_pkg.sv b/hw/vendor/openhwgroup_cva6/core/include/ariane_pkg.sv
index d3f4463e..df5faf4c 100644
--- a/hw/vendor/openhwgroup_cva6/core/include/ariane_pkg.sv
+++ b/hw/vendor/openhwgroup_cva6/core/include/ariane_pkg.sv
@@ -812,6 +812,7 @@ package ariane_pkg;
         logic [DCACHE_TID_WIDTH-1:0]   data_id;
         logic                          kill_req;
         logic                          tag_valid;
+        logic [riscv::PLEN-1:0]        mcast_mask;
     } dcache_req_i_t;
 
     typedef struct packed {
diff --git a/hw/vendor/openhwgroup_cva6/core/include/riscv_pkg.sv b/hw/vendor/openhwgroup_cva6/core/include/riscv_pkg.sv
index 6fe37fef..f8f9f43f 100644
--- a/hw/vendor/openhwgroup_cva6/core/include/riscv_pkg.sv
+++ b/hw/vendor/openhwgroup_cva6/core/include/riscv_pkg.sv
@@ -447,6 +447,8 @@ package riscv;
         CSR_DPC            = 12'h7b1,
         CSR_DSCRATCH0      = 12'h7b2, // optional
         CSR_DSCRATCH1      = 12'h7b3, // optional
+        // Custom (Machine Mode - R/W)
+        CSR_MCAST_MASK     = 12'h7C0,
         // Counters and Timers (User Mode - R/O Shadows)
         CSR_CYCLE          = 12'hC00,
         CSR_CYCLEH         = 12'hC80,
diff --git a/hw/vendor/openhwgroup_cva6/core/include/std_cache_pkg.sv b/hw/vendor/openhwgroup_cva6/core/include/std_cache_pkg.sv
index 3da4ba81..b04b4141 100644
--- a/hw/vendor/openhwgroup_cva6/core/include/std_cache_pkg.sv
+++ b/hw/vendor/openhwgroup_cva6/core/include/std_cache_pkg.sv
@@ -40,6 +40,7 @@ package std_cache_pkg;
         logic         we;
         logic [63:0]  wdata;
         logic         bypass;
+        logic [riscv::PLEN-1:0] mcast_mask;
     } miss_req_t;
 
     typedef struct packed {
@@ -52,6 +53,7 @@ package std_cache_pkg;
         logic                we;
         logic [7:0]          be;
         logic [1:0]          size;
+        logic [riscv::PLEN-1:0] mcast_mask;
     } bypass_req_t;
 
     typedef struct packed {
diff --git a/hw/vendor/openhwgroup_cva6/core/load_store_unit.sv b/hw/vendor/openhwgroup_cva6/core/load_store_unit.sv
index 51872b58..6c222859 100644
--- a/hw/vendor/openhwgroup_cva6/core/load_store_unit.sv
+++ b/hw/vendor/openhwgroup_cva6/core/load_store_unit.sv
@@ -24,6 +24,7 @@ module load_store_unit import ariane_pkg::*; #(
     input  logic                     amo_valid_commit_i,
 
     input  fu_data_t                 fu_data_i,
+    input  riscv::xlen_t             mcast_mask_i,
     output logic                     lsu_ready_o,              // FU is ready e.g. not busy
     input  logic                     lsu_valid_i,              // Input is valid
 
@@ -239,6 +240,7 @@ module load_store_unit import ariane_pkg::*; #(
         .flush_i,
         .no_st_pending_o,
         .store_buffer_empty_o  ( store_buffer_empty   ),
+        .mcast_mask_i          ( mcast_mask_i         ),
 
         .valid_i               ( st_valid_i           ),
         .lsu_ctrl_i            ( lsu_ctrl             ),
diff --git a/hw/vendor/openhwgroup_cva6/core/load_unit.sv b/hw/vendor/openhwgroup_cva6/core/load_unit.sv
index d8e9eeaa..a88c1e2a 100644
--- a/hw/vendor/openhwgroup_cva6/core/load_unit.sv
+++ b/hw/vendor/openhwgroup_cva6/core/load_unit.sv
@@ -98,6 +98,7 @@ module load_unit import ariane_pkg::*; #(
         load_data_d          = load_data_q;
         translation_req_o    = 1'b0;
         req_port_o.data_req  = 1'b0;
+        req_port_o.mcast_mask = '0;
         // tag control
         req_port_o.kill_req  = 1'b0;
         req_port_o.tag_valid = 1'b0;
diff --git a/hw/vendor/openhwgroup_cva6/core/mmu_sv32/cva6_ptw_sv32.sv b/hw/vendor/openhwgroup_cva6/core/mmu_sv32/cva6_ptw_sv32.sv
index 0c2fd770..06dcc501 100644
--- a/hw/vendor/openhwgroup_cva6/core/mmu_sv32/cva6_ptw_sv32.sv
+++ b/hw/vendor/openhwgroup_cva6/core/mmu_sv32/cva6_ptw_sv32.sv
@@ -191,6 +191,7 @@ module cva6_ptw_sv32 import ariane_pkg::*; #(
         req_port_o.data_req       = 1'b0;
         req_port_o.data_size      = 2'b10;
         req_port_o.data_we        = 1'b0;
+        req_port_o.mcast_mask     = '0;
         ptw_error_o               = 1'b0;
         ptw_access_exception_o    = 1'b0;
         shared_tlb_update_o.valid = 1'b0;
diff --git a/hw/vendor/openhwgroup_cva6/core/mmu_sv39/ptw.sv b/hw/vendor/openhwgroup_cva6/core/mmu_sv39/ptw.sv
index 45331d27..7b3686c3 100644
--- a/hw/vendor/openhwgroup_cva6/core/mmu_sv39/ptw.sv
+++ b/hw/vendor/openhwgroup_cva6/core/mmu_sv39/ptw.sv
@@ -184,6 +184,7 @@ module ptw import ariane_pkg::*; #(
         req_port_o.data_be     = 8'hFF;
         req_port_o.data_size   = 2'b11;
         req_port_o.data_we     = 1'b0;
+        req_port_o.mcast_mask  = '0;
         ptw_error_o            = 1'b0;
         ptw_access_exception_o = 1'b0;
         itlb_update_o.valid    = 1'b0;
diff --git a/hw/vendor/openhwgroup_cva6/core/store_buffer.sv b/hw/vendor/openhwgroup_cva6/core/store_buffer.sv
index 17e088ad..b92f8da2 100644
--- a/hw/vendor/openhwgroup_cva6/core/store_buffer.sv
+++ b/hw/vendor/openhwgroup_cva6/core/store_buffer.sv
@@ -21,6 +21,7 @@ module store_buffer import ariane_pkg::*; (
                                           // otherwise we will run in a deadlock with the memory arbiter
     output logic         no_st_pending_o, // non-speculative queue is empty (e.g.: everything is committed to the memory hierarchy)
     output logic         store_buffer_empty_o, // there is no store pending in neither the speculative unit or the non-speculative queue
+    input  riscv::xlen_t mcast_mask_i,    // Multicast mask
 
     input  logic [11:0]  page_offset_i,         // check for the page offset (the last 12 bit if the current load matches them)
     output logic         page_offset_matches_o, // the above input page offset matches -> let the store buffer drain
@@ -53,8 +54,15 @@ module store_buffer import ariane_pkg::*; (
         logic [(riscv::XLEN/8)-1:0]  be;
         logic [1:0]                  data_size;
         logic                        valid;     // this entry is valid, we need this for checking if the address offset matches
-    } speculative_queue_n [DEPTH_SPEC-1:0], speculative_queue_q [DEPTH_SPEC-1:0],
-      commit_queue_n [DEPTH_COMMIT-1:0],    commit_queue_q [DEPTH_COMMIT-1:0];
+    } speculative_queue_n [DEPTH_SPEC-1:0], speculative_queue_q [DEPTH_SPEC-1:0];
+    struct packed {
+        logic [riscv::PLEN-1:0]      address;
+        riscv::xlen_t                data;
+        logic [(riscv::XLEN/8)-1:0]  be;
+        logic [1:0]                  data_size;
+        logic                        valid;     // this entry is valid, we need this for checking if the address offset matches
+        logic [riscv::PLEN-1:0]      mcast_mask;
+    } commit_queue_n [DEPTH_COMMIT-1:0], commit_queue_q [DEPTH_COMMIT-1:0];
 
     // keep a status count for both buffers
     logic [$clog2(DEPTH_SPEC):0] speculative_status_cnt_n, speculative_status_cnt_q;
@@ -139,6 +147,7 @@ module store_buffer import ariane_pkg::*; (
     assign req_port_o.data_wdata    = commit_queue_q[commit_read_pointer_q].data;
     assign req_port_o.data_be       = commit_queue_q[commit_read_pointer_q].be;
     assign req_port_o.data_size     = commit_queue_q[commit_read_pointer_q].data_size;
+    assign req_port_o.mcast_mask    = commit_queue_q[commit_read_pointer_q].mcast_mask;
 
     assign mem_paddr_o              = commit_queue_n[commit_read_pointer_n].address;
 
@@ -174,7 +183,12 @@ module store_buffer import ariane_pkg::*; (
 
         // shift the store request from the speculative buffer to the non-speculative
         if (commit_i) begin
-            commit_queue_n[commit_write_pointer_q] = speculative_queue_q[speculative_read_pointer_q];
+            commit_queue_n[commit_write_pointer_q].address    = speculative_queue_q[speculative_read_pointer_q].address;
+            commit_queue_n[commit_write_pointer_q].data       = speculative_queue_q[speculative_read_pointer_q].data;
+            commit_queue_n[commit_write_pointer_q].be         = speculative_queue_q[speculative_read_pointer_q].be;
+            commit_queue_n[commit_write_pointer_q].data_size  = speculative_queue_q[speculative_read_pointer_q].data_size;
+            commit_queue_n[commit_write_pointer_q].valid      = speculative_queue_q[speculative_read_pointer_q].valid;
+            commit_queue_n[commit_write_pointer_q].mcast_mask = mcast_mask_i[riscv::PLEN-1:0];
             commit_write_pointer_n = commit_write_pointer_n + 1'b1;
             commit_status_cnt++;
         end
diff --git a/hw/vendor/openhwgroup_cva6/core/store_unit.sv b/hw/vendor/openhwgroup_cva6/core/store_unit.sv
index e6b5204e..b9296010 100644
--- a/hw/vendor/openhwgroup_cva6/core/store_unit.sv
+++ b/hw/vendor/openhwgroup_cva6/core/store_unit.sv
@@ -19,6 +19,7 @@ module store_unit import ariane_pkg::*; (
     input  logic                     flush_i,
     output logic                     no_st_pending_o,
     output logic                     store_buffer_empty_o,
+    input  riscv::xlen_t             mcast_mask_i,
     // store unit input port
     input  logic                     valid_i,
     input  lsu_ctrl_t                lsu_ctrl_i,
@@ -219,6 +220,7 @@ module store_unit import ariane_pkg::*; (
         .flush_i,
         .no_st_pending_o,
         .store_buffer_empty_o,
+        .mcast_mask_i,
         .page_offset_i,
         .page_offset_matches_o,
         .commit_i,
diff --git a/hw/vendor/openhwgroup_cva6/corev_apu/tb/axi_mcast_adapter.sv b/hw/vendor/openhwgroup_cva6/corev_apu/tb/axi_mcast_adapter.sv
new file mode 100644
index 00000000..d39b97d7
--- /dev/null
+++ b/hw/vendor/openhwgroup_cva6/corev_apu/tb/axi_mcast_adapter.sv
@@ -0,0 +1,461 @@
+/* Copyright 2018 ETH Zurich and University of Bologna.
+ * Copyright and related rights are licensed under the Solderpad Hardware
+ * License, Version 0.51 (the “License”); you may not use this file except in
+ * compliance with the License.  You may obtain a copy of the License at
+ * http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
+ * or agreed to in writing, software, hardware and materials distributed under
+ * this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * File:  axi_adapter.sv
+ * Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>
+ * Date:   1.8.2018
+ *
+ * Description: Manages communication with the AXI Bus
+ */
+//import std_cache_pkg::*;
+
+module axi_mcast_adapter #(
+  parameter int unsigned DATA_WIDTH            = 256,
+  parameter logic        CRITICAL_WORD_FIRST   = 0, // the AXI subsystem needs to support wrapping reads for this feature
+  parameter int unsigned CACHELINE_BYTE_OFFSET = 8,
+  parameter int unsigned AXI_ADDR_WIDTH        = 0,
+  parameter int unsigned AXI_DATA_WIDTH        = 0,
+  parameter int unsigned AXI_ID_WIDTH          = 0,
+  parameter int unsigned AXI_USER_WIDTH        = 0,
+  parameter type axi_req_t = ariane_axi::req_t,
+  parameter type axi_rsp_t = ariane_axi::resp_t
+)(
+  input  logic                             clk_i,  // Clock
+  input  logic                             rst_ni, // Asynchronous reset active low
+
+  output logic                             busy_o,
+  input  logic                             req_i,
+  input  ariane_axi::ad_req_t              type_i,
+  input  ariane_pkg::amo_t                 amo_i,
+  output logic                             gnt_o,
+  input  logic [riscv::XLEN-1:0]           addr_i,
+  input  logic [riscv::XLEN-1:0]           mcast_mask_i,
+  input  logic                             we_i,
+  input  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0]      wdata_i,
+  input  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][(AXI_DATA_WIDTH/8)-1:0]  be_i,
+  input  logic [1:0]                       size_i,
+  input  logic [AXI_ID_WIDTH-1:0]          id_i,
+  input  logic [AXI_USER_WIDTH-1:0]        user_i,
+  // read port
+  output logic                             valid_o,
+  output logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0] rdata_o,
+  output logic [AXI_ID_WIDTH-1:0]          id_o,
+  // critical word - read port
+  output logic [AXI_DATA_WIDTH-1:0]        critical_word_o,
+  output logic                             critical_word_valid_o,
+  // AXI port
+  output axi_req_t                 axi_req_o,
+  input  axi_rsp_t                 axi_resp_i
+);
+  localparam BURST_SIZE = (DATA_WIDTH/AXI_DATA_WIDTH)-1;
+  localparam ADDR_INDEX = ($clog2(DATA_WIDTH/AXI_DATA_WIDTH) > 0) ? $clog2(DATA_WIDTH/AXI_DATA_WIDTH) : 1;
+
+  enum logic [3:0] {
+    IDLE, WAIT_B_VALID, WAIT_AW_READY, WAIT_LAST_W_READY, WAIT_LAST_W_READY_AW_READY, WAIT_AW_READY_BURST,
+    WAIT_R_VALID, WAIT_R_VALID_MULTIPLE, COMPLETE_READ, WAIT_AMO_R_VALID
+  } state_q, state_d;
+
+  // counter for AXI transfers
+  logic [ADDR_INDEX-1:0] cnt_d, cnt_q;
+  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0][AXI_DATA_WIDTH-1:0] cache_line_d, cache_line_q;
+  // save the address for a read, as we allow for non-cacheline aligned accesses
+  logic [(DATA_WIDTH/AXI_DATA_WIDTH)-1:0] addr_offset_d, addr_offset_q;
+  logic [AXI_ID_WIDTH-1:0]    id_d, id_q;
+  logic [ADDR_INDEX-1:0]      index;
+  // save the atomic operation and size
+  ariane_pkg::amo_t amo_d, amo_q;
+  logic [1:0] size_d, size_q;
+
+  // Busy if we're not idle
+  assign busy_o = state_q != IDLE;
+
+  always_comb begin : axi_fsm
+    // Default assignments
+    axi_req_o.aw_valid  = 1'b0;
+    // Cast to AXI address width
+    axi_req_o.aw.addr   = addr_i;
+    axi_req_o.aw.prot   = 3'b0;
+    axi_req_o.aw.region = 4'b0;
+    axi_req_o.aw.len    = 8'b0;
+    axi_req_o.aw.size   = {1'b0, size_i}; // 1, 2, 4 or 8 bytes
+    axi_req_o.aw.burst  = axi_pkg::BURST_INCR; // Use BURST_INCR for AXI regular transaction
+    axi_req_o.aw.lock   = 1'b0;
+    axi_req_o.aw.cache  = axi_pkg::CACHE_MODIFIABLE;
+    axi_req_o.aw.qos    = 4'b0;
+    axi_req_o.aw.id     = id_i;
+    axi_req_o.aw.atop   = atop_from_amo(amo_i);
+    axi_req_o.aw.user   = (mcast_mask_i << AXI_USER_WIDTH) | user_i;
+
+    axi_req_o.ar_valid  = 1'b0;
+    // Cast to AXI address width
+    axi_req_o.ar.addr   = addr_i;
+    // in case of a single request or wrapping transfer we can simply begin at the address, if we want to request a cache-line
+    // with an incremental transfer we need to output the corresponding base address of the cache line
+    if (!CRITICAL_WORD_FIRST && type_i != ariane_axi::SINGLE_REQ) begin
+      axi_req_o.ar.addr[CACHELINE_BYTE_OFFSET-1:0] = '0;
+    end
+    axi_req_o.ar.prot   = 3'b0;
+    axi_req_o.ar.region = 4'b0;
+    axi_req_o.ar.len    = 8'b0;
+    axi_req_o.ar.size   = {1'b0, size_i}; // 1, 2, 4 or 8 bytes
+    axi_req_o.ar.burst  = (CRITICAL_WORD_FIRST ? axi_pkg::BURST_WRAP : axi_pkg::BURST_INCR); // wrapping transfer in case of a critical word first strategy
+    axi_req_o.ar.lock   = 1'b0;
+    axi_req_o.ar.cache  = axi_pkg::CACHE_MODIFIABLE;
+    axi_req_o.ar.qos    = 4'b0;
+    axi_req_o.ar.id     = id_i;
+    axi_req_o.ar.user   = user_i;
+
+    axi_req_o.w_valid   = 1'b0;
+    axi_req_o.w.data    = wdata_i[0];
+    axi_req_o.w.strb    = be_i[0];
+    axi_req_o.w.last    = 1'b0;
+    axi_req_o.w.user    = user_i;
+
+    axi_req_o.b_ready   = 1'b0;
+    axi_req_o.r_ready   = 1'b0;
+
+    gnt_o    = 1'b0;
+    valid_o  = 1'b0;
+    id_o     = axi_resp_i.r.id;
+
+    critical_word_o       = axi_resp_i.r.data;
+    critical_word_valid_o = 1'b0;
+    rdata_o               = cache_line_q;
+
+    state_d       = state_q;
+    cnt_d         = cnt_q;
+    cache_line_d  = cache_line_q;
+    addr_offset_d = addr_offset_q;
+    id_d          = id_q;
+    amo_d         = amo_q;
+    size_d        = size_q;
+    index         = '0;
+
+    case (state_q)
+
+      IDLE: begin
+        cnt_d = '0;
+        // we have an incoming request
+        if (req_i) begin
+          // is this a read or write?
+          // write
+          if (we_i) begin
+            // the data is valid
+            axi_req_o.aw_valid = 1'b1;
+            axi_req_o.w_valid  = 1'b1;
+            // store-conditional requires exclusive access
+            axi_req_o.aw.lock = amo_i == ariane_pkg::AMO_SC;
+            // its a single write
+            if (type_i == ariane_axi::SINGLE_REQ) begin
+              // only a single write so the data is already the last one
+              axi_req_o.w.last   = 1'b1;
+              // single req can be granted here
+              gnt_o = axi_resp_i.aw_ready & axi_resp_i.w_ready;
+              case ({axi_resp_i.aw_ready, axi_resp_i.w_ready})
+                2'b11: state_d = WAIT_B_VALID;
+                2'b01: state_d = WAIT_AW_READY;
+                2'b10: state_d = WAIT_LAST_W_READY;
+                default: state_d = IDLE;
+              endcase
+
+              if (axi_resp_i.aw_ready) begin
+                amo_d  = amo_i;
+                size_d = size_i;
+              end
+
+            // its a request for the whole cache line
+            end else begin
+              // bursts of AMOs unsupported
+              assert (amo_i == ariane_pkg::AMO_NONE) 
+                else $fatal("Bursts of atomic operations are not supported");
+
+              axi_req_o.aw.len = BURST_SIZE; // number of bursts to do
+              axi_req_o.w.data = wdata_i[0];
+              axi_req_o.w.strb = be_i[0];
+
+              if (axi_resp_i.w_ready)
+                cnt_d = BURST_SIZE - 1;
+              else
+                cnt_d = BURST_SIZE;
+
+              case ({axi_resp_i.aw_ready, axi_resp_i.w_ready})
+                2'b11: state_d = WAIT_LAST_W_READY;
+                2'b01: state_d = WAIT_LAST_W_READY_AW_READY;
+                2'b10: state_d = WAIT_LAST_W_READY;
+                default:;
+              endcase
+            end
+          // read
+          end else begin
+
+            axi_req_o.ar_valid = 1'b1;
+            // load-reserved requires exclusive access
+            axi_req_o.ar.lock = amo_i == ariane_pkg::AMO_LR;
+
+            gnt_o = axi_resp_i.ar_ready;
+            if (type_i != ariane_axi::SINGLE_REQ) begin
+              assert (amo_i == ariane_pkg::AMO_NONE) 
+                else $fatal("Bursts of atomic operations are not supported");
+
+              axi_req_o.ar.len = BURST_SIZE;
+              cnt_d = BURST_SIZE;
+            end
+
+            if (axi_resp_i.ar_ready) begin
+              state_d = (type_i == ariane_axi::SINGLE_REQ) ? WAIT_R_VALID : WAIT_R_VALID_MULTIPLE;
+              addr_offset_d = addr_i[ADDR_INDEX-1+3:3];
+            end
+          end
+        end
+      end
+
+      // ~> from single write
+      WAIT_AW_READY: begin
+        axi_req_o.aw_valid = 1'b1;
+
+        if (axi_resp_i.aw_ready) begin
+          gnt_o   = 1'b1;
+          state_d = WAIT_B_VALID;
+          amo_d   = amo_i;
+          size_d  = size_i;
+        end
+      end
+
+      // ~> we need to wait for an aw_ready and there is at least one outstanding write
+      WAIT_LAST_W_READY_AW_READY: begin
+        axi_req_o.w_valid  = 1'b1;
+        axi_req_o.w.last   = (cnt_q == '0);
+        if (type_i == ariane_axi::SINGLE_REQ) begin
+          axi_req_o.w.data = wdata_i[0];
+          axi_req_o.w.strb = be_i[0];
+        end else begin
+          axi_req_o.w.data = wdata_i[BURST_SIZE-cnt_q];
+          axi_req_o.w.strb = be_i[BURST_SIZE-cnt_q];
+        end
+        axi_req_o.aw_valid = 1'b1;
+        // we are here because we want to write a cache line
+        axi_req_o.aw.len   = BURST_SIZE;
+        // we got an aw_ready
+        case ({axi_resp_i.aw_ready, axi_resp_i.w_ready})
+          // we got an aw ready
+          2'b01: begin
+            // are there any outstanding transactions?
+            if (cnt_q == 0)
+              state_d = WAIT_AW_READY_BURST;
+            else // yes, so reduce the count and stay here
+              cnt_d = cnt_q - 1;
+          end
+          2'b10: state_d = WAIT_LAST_W_READY;
+          2'b11: begin
+            // we are finished
+            if (cnt_q == 0) begin
+              state_d = WAIT_B_VALID;
+              gnt_o   = 1'b1;
+            // there are outstanding transactions
+            end else begin
+              state_d = WAIT_LAST_W_READY;
+              cnt_d   = cnt_q - 1;
+            end
+          end
+          default:;
+         endcase
+
+      end
+
+      // ~> all data has already been sent, we are only waiting for the aw_ready
+      WAIT_AW_READY_BURST: begin
+        axi_req_o.aw_valid = 1'b1;
+        axi_req_o.aw.len   = BURST_SIZE;
+
+        if (axi_resp_i.aw_ready) begin
+          state_d  = WAIT_B_VALID;
+          gnt_o    = 1'b1;
+        end
+      end
+
+      // ~> from write, there is an outstanding write
+      WAIT_LAST_W_READY: begin
+        axi_req_o.w_valid = 1'b1;
+
+        if (type_i != ariane_axi::SINGLE_REQ) begin
+          axi_req_o.w.data = wdata_i[BURST_SIZE-cnt_q];
+          axi_req_o.w.strb = be_i[BURST_SIZE-cnt_q];
+        end
+
+        // this is the last write
+        if (cnt_q == '0) begin
+          axi_req_o.w.last = 1'b1;
+          if (axi_resp_i.w_ready) begin
+            state_d = WAIT_B_VALID;
+            gnt_o   = 1'b1;
+          end
+        end else if (axi_resp_i.w_ready) begin
+          cnt_d = cnt_q - 1;
+        end
+      end
+
+      // ~> finish write transaction
+      WAIT_B_VALID: begin
+        id_o = axi_resp_i.b.id;
+
+        // Write is valid
+        if (axi_resp_i.b_valid) begin
+          axi_req_o.b_ready = 1'b1;
+
+          // some atomics must wait for read data
+          // we only accept it after accepting bvalid
+          if (amo_returns_data(amo_q)) begin
+            if (axi_resp_i.r_valid) begin
+              // return read data if valid
+              valid_o           = 1'b1;
+              axi_req_o.r_ready = 1'b1;
+              state_d           = IDLE;
+              rdata_o           = axi_resp_i.r.data;
+            end else begin
+              // wait otherwise
+              state_d = WAIT_AMO_R_VALID;
+            end
+          end else begin
+            valid_o = 1'b1;
+            state_d = IDLE;
+
+            // store-conditional response
+            if (amo_q == ariane_pkg::AMO_SC) begin
+              if (axi_resp_i.b.resp == axi_pkg::RESP_EXOKAY) begin
+                // success -> return 0
+                rdata_o = 1'b0;
+              end else begin
+                // failure -> when request is 64-bit, return 1;
+                // when request is 32-bit place a 1 in both upper
+                // and lower half words. The right word will be
+                // realigned/masked externally
+                rdata_o = size_q == 2'b10 ? (1'b1 << 32) | 64'b1 : 64'b1;
+              end
+            end
+          end
+        end
+      end
+
+      // ~> some atomics wait for read data
+      WAIT_AMO_R_VALID: begin
+        // acknowledge data and terminate atomic
+        if (axi_resp_i.r_valid) begin
+          axi_req_o.r_ready = 1'b1;
+          state_d           = IDLE;
+          valid_o           = 1'b1;
+          rdata_o           = axi_resp_i.r.data;
+        end
+      end
+
+      // ~> cacheline read, single read
+      WAIT_R_VALID_MULTIPLE, WAIT_R_VALID: begin
+        if (CRITICAL_WORD_FIRST)
+          index = addr_offset_q + (BURST_SIZE-cnt_q);
+        else
+          index = BURST_SIZE-cnt_q;
+
+        // reads are always wrapping here
+        axi_req_o.r_ready = 1'b1;
+        // this is the first read a.k.a the critical word
+        if (axi_resp_i.r_valid) begin
+          if (CRITICAL_WORD_FIRST) begin
+            // this is the first word of a cacheline read, e.g.: the word which was causing the miss
+            if (state_q == WAIT_R_VALID_MULTIPLE && cnt_q == BURST_SIZE) begin
+              critical_word_valid_o = 1'b1;
+              critical_word_o       = axi_resp_i.r.data;
+            end
+          end else begin
+            // check if the address offset matches - then we are getting the critical word
+            if (index == addr_offset_q) begin
+              critical_word_valid_o = 1'b1;
+              critical_word_o       = axi_resp_i.r.data;
+            end
+          end
+
+          // this is the last read
+          if (axi_resp_i.r.last) begin
+            id_d    = axi_resp_i.r.id;
+            state_d = COMPLETE_READ;
+          end
+
+          // save the word
+          if (state_q == WAIT_R_VALID_MULTIPLE) begin
+            cache_line_d[index] = axi_resp_i.r.data;
+
+          end else
+            cache_line_d[0] = axi_resp_i.r.data;
+
+          // Decrease the counter
+          cnt_d = cnt_q - 1;
+        end
+      end
+      // ~> read is complete
+      COMPLETE_READ: begin
+        valid_o = 1'b1;
+        state_d = IDLE;
+        id_o    = id_q;
+      end
+    endcase
+  end
+
+  // ----------------
+  // Registers
+  // ----------------
+  always_ff @(posedge clk_i or negedge rst_ni) begin
+    if (~rst_ni) begin
+      // start in flushing state and initialize the memory
+      state_q       <= IDLE;
+      cnt_q         <= '0;
+      cache_line_q  <= '0;
+      addr_offset_q <= '0;
+      id_q          <= '0;
+      amo_q         <= ariane_pkg::AMO_NONE;
+      size_q        <= '0;
+    end else begin
+      state_q       <= state_d;
+      cnt_q         <= cnt_d;
+      cache_line_q  <= cache_line_d;
+      addr_offset_q <= addr_offset_d;
+      id_q          <= id_d;
+      amo_q         <= amo_d;
+      size_q        <= size_d;
+    end
+  end
+
+  function automatic axi_pkg::atop_t atop_from_amo(ariane_pkg::amo_t amo);
+    axi_pkg::atop_t result = 6'b000000;
+
+    unique case(amo)
+      ariane_pkg::AMO_NONE: result = {axi_pkg::ATOP_NONE, 4'b0000};
+      ariane_pkg::AMO_SWAP: result = {axi_pkg::ATOP_ATOMICSWAP};
+      ariane_pkg::AMO_ADD : result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_ADD};
+      ariane_pkg::AMO_AND : result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_CLR};
+      ariane_pkg::AMO_OR  : result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SET};
+      ariane_pkg::AMO_XOR : result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_EOR};
+      ariane_pkg::AMO_MAX : result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SMAX};
+      ariane_pkg::AMO_MAXU: result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_UMAX};
+      ariane_pkg::AMO_MIN : result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SMIN};
+      ariane_pkg::AMO_MINU: result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_UMIN};
+      ariane_pkg::AMO_CAS1: result = {axi_pkg::ATOP_NONE, 4'b0000}; // Unsupported
+      ariane_pkg::AMO_CAS2: result = {axi_pkg::ATOP_NONE, 4'b0000}; // Unsupported
+      default: result = 6'b000000;
+    endcase
+
+    return result;
+  endfunction
+
+  function automatic logic amo_returns_data(ariane_pkg::amo_t amo);
+    axi_pkg::atop_t atop           = atop_from_amo(amo);
+    logic           is_load        = atop[5:4] == axi_pkg::ATOP_ATOMICLOAD;
+    logic           is_swap_or_cmp = atop[5:4] == axi_pkg::ATOP_ATOMICSWAP[5:4];
+    return is_load || is_swap_or_cmp;
+  endfunction
+
+endmodule
-- 
2.28.0

